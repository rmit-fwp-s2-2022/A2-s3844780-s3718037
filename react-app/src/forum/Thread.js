import React, { useState, useEffect } from "react";
import { getUserByID, newComment, getCommentsByID, dateFormatter, getUserInfo, storeReaction, getReactionCount } from "../Util";

import Comment from "./Comment";
import EditPost from "./EditPost";
import DeletePost from "./DeletePost";

import { useNavigate } from "react-router-dom";
import ReactQuill from "react-quill";
import "react-quill/dist/quill.bubble.css";
import EditIcon from '@material-ui/icons/Edit';
import DeleteIcon from '@material-ui/icons/Delete';
import ArrowUpward from '@material-ui/icons/ArrowUpward';
import ArrowDownward from '@material-ui/icons/ArrowDownward';

export default function Thread(props) {

    // Used for creating individual comments
    const [comment, setComment] = useState("")
    // Get and set all comments
    const [comments, setComments] = useState("");
    const [errorMessage, setErrorMessage] = useState(null)
    const [user, setUser] = useState(null)
    // Allow comments to be returned before displaying them
    const [isLoading, setIsLoading] = useState(true);
    // Allow comments to re-render upon new comment
    const [change, setChange] = useState(false);
    // Allow new comments to be created before re-render
    const [createComment, setCreateComment] = useState(false);
    // User reactions state
    const [reaction, setReaction] = useState(null);
    // Reaction score
    const [reactionScore, setReactionScore] = useState(null);

    const navigate = useNavigate();

    // Fill form elements with current thread data.
    const resetInputs = {
        post: props.post,
        postPic: props.postPic
    };

    // Controls inputs that are displayed
    const [inputs, setInputs] = useState(resetInputs)
    // Supports hide/show component
    const [showThread, setShowThread] = useState(true)

    useEffect(() => {
        setShowThread(true)
    }, [props]);

    // Obtain user by ID
    useEffect(() => {
        const fetchUser = async () => {
            const user = await getUserByID(props.userID)
            setUser(user)
        }
        fetchUser()
    }, [])

    // Stop a comment from being created if it breaks specific rules
    function errorCheck() {
        // Trim the post text.
        // const commentTrimmed = comment.trim()
        const commentTrimmed = comment.replace(/<(.|\n)*?>/g, "").trim()

        // Set error if comment is empty.
        if (comment.replace(/<(.|\n)*?>/g, "").trim().length === 0) {
            setErrorMessage("Comment cannot be left blank.")
            // Reset the createComment state
            setCreateComment(false);
            return true
        }
        // Set error if comment exceeds 600 characters.
        if (commentTrimmed.length > 600) {
            const overLimit = commentTrimmed.length - 600
            const characterPostfix = overLimit === 1 ? "character" : "characters"
            setErrorMessage("You are " + overLimit + " " + characterPostfix + " over the character limit.")
            // Reset the createComment state
            setCreateComment(false);
            return true
        }
        return false
    }

    // Create a new comment and then cause a re-render.
    useEffect(() => {
        const createNewComment = async () => {
            // Remove unessesary 'p' and 'br' tags auto generated by quill
            const filteredComment = comment.replaceAll("<p><br></p>", "");
            // Create a new comment.
            newComment(props.threadID, filteredComment)
            // Reset post content and error message.
            setComment("")
            setErrorMessage(null)
            // Display the comments after loading.
            setIsLoading(false);
            // Allow comments to re-render.
            setChange(true)
            // Reset the createComment state.
            setCreateComment(false);
        }
        if (createComment === true) {
            createNewComment();
        }
    }, [createComment])

    // Update change state
    const handleClick = event => {
        // If no errors exist then continue.
        if (errorCheck() === false) {
            // Trigger new comment to be created.
            setCreateComment(true);
            // Hide comments while loading.
            setIsLoading(true);
        }
    };

    // Get all comments by thread ID
    useEffect(() => {
        async function loadComments() {
            const allComments = await getCommentsByID(props.threadID);

            setComments(allComments);
            // Display the comments after loading
            setIsLoading(false);
        }
        loadComments();
        // Reset change useState
        setChange(false)
    }, [change]);

    // Create/update reaction and set reaction scores.
    useEffect(() => {
        async function createReaction() {
            // Create a new reaction and update scores
            if (reaction !== null) {
                // Store/update reaction in database
                await storeReaction(reaction, currentUser.userID, props.threadID, "threadID")
                const score = await getReactionCount(props.threadID, "threadID");
                setReactionScore(score)
            }
            // Update scores upon render
            if (reaction === null) {
                const score = await getReactionCount(props.threadID, "threadID");
                setReactionScore(score)
            }
        }
        createReaction();
    }, [reaction]);

    // Hide the component if the thread was deleted.
    if (showThread === false) {
        return null
    }

    // Update the current comment from textarea's input.
    const handleInputChange = (event) => {
        setComment(event.target.value)
    }

    // Initiate creating a new comment
    const userComment = (event) => {
        // Prevent page from refreshing/reloading
        event.preventDefault();
    }

    // View Profile of User
    const viewProfile = (event) => {
        event.preventDefault();
        navigate("/profile", { state: { user: user } });
    }

    // Get logged-in user. Stop user from being able to modify other users posts.
    const currentUser = getUserInfo()

    // Handle upvoting a post event
    const upvotePost = (event) => {
        event.preventDefault();
        setReaction(1)
    }

    // Handle upvoting a post event
    const downvotePost = (event) => {
        event.preventDefault();
        setReaction(0)
    }


    return (
        <>
            {/* Edit thread */}
            <EditPost threadID={props.threadID} post={props.post} postPic={props.postPic} passPost={setInputs} />
            {/* Delete thread */}
            <DeletePost threadID={props.threadID} passShowThread={setShowThread} />
            <div className="container mb-3">
                <div className="card mx-auto thread-card border-0" style={{ width: '800px' }}>
                    {/* Start of thread row */}
                    <div className="row">
                        <div className="col-sm-1">
                            <img className="card-img rounded-circle profile-pic mx-4 my-3 border" alt="" src={user != null ? user.profilePic : ""} />
                        </div>
                        <div className="col-sm-9 main-textarea">
                            <div className="card-body mx-5 mt-1 pb-0 thread-body">
                                <h5 className="card-title pt-1">{user != null ?
                                    <a href="" onClick={viewProfile} className="profile-link">{user.name}</a> : ""}
                                    <span className="text-muted thread-bar"> · {dateFormatter(props.postDate)}  </span>
                                    <span className="text-muted thread-bar"> · {reactionScore === null ? 0 + " Score" : reactionScore + " Score"}  </span>
                                    {/* Only allow the origional user of a post to edit or delete it */}
                                    {currentUser.userID == props.userID ?
                                        <>
                                            <EditIcon className="icon-button" data-bs-toggle="modal" data-bs-target={"#edit-post-modal" + props.threadID} style={{ color: 'grey', fontSize: 20 }} />
                                            <DeleteIcon className="icon-button" data-bs-toggle="modal" data-bs-target={"#delete-post-modal" + props.threadID} style={{ color: 'grey', fontSize: 20 }} />
                                        </>
                                        : <div></div>
                                    }
                                </h5>
                                <div className="card-subtitle pt-1" dangerouslySetInnerHTML={{ __html: inputs.post }} />
                                {
                                    inputs.postPic === null || inputs.postPic === undefined || inputs.postPic === "" ? "" :
                                        <img className="border rounded post-image mb-1" src={inputs.postPic} />
                                }
                            </div>
                        </div>
                        <div className="col-sm-2">
                            <>
                                <a href="#" className="btn mt-3 reaction-icons" onClick={upvotePost}><ArrowUpward className="up-icon" style={{ fontSize: 30, color: '#6C757D' }} /></a>
                                <a href="#" className="btn mt-3 reaction-icons" onClick={downvotePost}><ArrowDownward className="down-icon" style={{ fontSize: 30, color: '#6C757D' }} /></a>

                            </>
                        </div>
                    </div>

                    <hr />
                    {/* Comments */}
                    {
                        comments === null || comments === undefined ? "" :
                            isLoading ? <div></div> :
                                comments.map((comment) =>
                                    <Comment
                                        key={comment.commentID}
                                        commentID={comment.commentID}
                                        userID={comment.userID}
                                        threadID={comment.threadID}
                                        commentText={comment.commentText}
                                        postDate={comment.updatedAt}
                                    />
                                )
                    }
                    {/* End of thread row */}
                    <form onSubmit={userComment}>
                        <div className="row">
                            <div className="col-sm-10 main-textarea">
                                <div className="card-body mx-2 pt-0">
                                    <h6 className="card-title reply-label">Add a reply
                                        {errorMessage !== null && <span className="error-comment-text">{'\u00A0'}{'\u00A0'} Error: {errorMessage}</span>}
                                    </h6>
                                    <ReactQuill className="form-control" name="comment" value={comment} onChange={setComment} onKeyDown={onkeydown} style={{ height: "38px" }} theme="bubble" placeholder="Post a message..." />
                                </div>
                            </div>
                            <div className="col-sm-2">
                                <button type="submit" onClick={handleClick} className="btn btn-secondary post-button px-4">Post</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </>
    )
}
